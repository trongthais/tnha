<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÑ Gi√°ng Sinh An L√†nh üéÑ</title>
    <link href="https://fonts.googleapis.com/css2?family=Lobster&family=Roboto:wght@700&family=Quicksand:wght@700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Roboto', sans-serif; color: #fff; }
        
        /* ===== WELCOME SCREEN ===== */
        #welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 40px;
            transition: opacity 0.8s;
        }
        
        #welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .title {
            font-family: 'Lobster', cursive;
            font-size: 48px;
            background: linear-gradient(45deg, #ff0000, #00ff00, #ff0000);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease infinite;
            text-shadow: 0 0 30px rgba(255,0,0,0.5);
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .buttons-container {
            display: flex;
            gap: 30px;
        }
        
        .btn-main {
            background: #000;
            border: 3px solid #ff0000;
            color: #fff;
            padding: 15px 40px;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 24px;
            cursor: pointer;
            border-radius: 15px;
            box-shadow: 0 0 20px #ff0000, inset 0 0 20px rgba(255,0,0,0.2);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .btn-main:hover {
            box-shadow: 0 0 40px #ff0000, inset 0 0 30px rgba(255,0,0,0.4);
            transform: scale(1.05);
        }
        
        .btn-main::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,0,0,0.3) 0%, transparent 70%);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        
        .gesture-guide {
            background: #000;
            border: 3px solid #ff0000;
            border-radius: 50px;
            padding: 20px 40px;
            display: flex;
            gap: 30px;
            align-items: center;
            box-shadow: 0 0 20px #ff0000;
        }
        
        .gesture-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .gesture-icon {
            font-size: 36px;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8));
        }
        
        .gesture-text {
            font-size: 14px;
            color: #fff;
            font-weight: 700;
        }
        
        .footer-text {
            position: absolute;
            bottom: 30px;
            font-family: 'Lobster', cursive;
            font-size: 20px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255,215,0,0.8);
            animation: blink 2s ease-in-out infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Corner Snowflakes */
        .corner-snow {
            position: fixed;
            font-size: 48px;
            filter: drop-shadow(0 0 15px #fff) drop-shadow(0 0 30px #fff);
            animation: rotate 4s linear infinite;
            z-index: 1001;
        }
        
        .corner-snow.top-left { top: 30px; left: 30px; }
        .corner-snow.top-right { top: 30px; right: 30px; animation-direction: reverse; }
        .corner-snow.bottom-left { bottom: 30px; left: 30px; animation-delay: 1s; }
        .corner-snow.bottom-right { bottom: 30px; right: 30px; animation-direction: reverse; animation-delay: 1s; }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* ===== POPUP MESSAGE ===== */
        #message-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background: #1a1a1a;
            border: 3px solid #ff0000;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 0 50px #ff0000;
            z-index: 2000;
            display: none;
        }
        
        #message-popup.show {
            display: block;
            animation: popIn 0.3s ease-out;
        }
        
        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #ff0000;
        }
        
        .popup-sender {
            font-family: 'Lobster', cursive;
            font-size: 24px;
            color: #ffd700;
        }
        
        .popup-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .popup-close:hover {
            transform: scale(1.2);
        }
        
        .popup-message {
            font-family: 'Quicksand', sans-serif;
            font-size: 18px;
            line-height: 1.6;
            color: #fff;
            text-align: center;
            padding: 20px;
        }
        
        /* ===== MAIN CANVAS ===== */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        /* ===== LOVE MODE TEXT ===== */
        #love-text {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Quicksand', sans-serif;
            font-size: 48px;
            color: #ff1493;
            text-shadow: 0 0 20px #ff1493, 0 0 40px #ff1493;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 100;
            pointer-events: none;
        }
        
        #love-text.show {
            opacity: 1;
        }
        
        /* Floating "I Love You" texts */
        .floating-love {
            position: fixed;
            font-family: 'Quicksand', sans-serif;
            color: #ff69b4;
            text-shadow: 0 0 10px #ff69b4;
            pointer-events: none;
            z-index: 50;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }
    </style>
</head>
<body>
    <!-- Corner Snowflakes -->
    <div class="corner-snow top-left">‚ùÑÔ∏è</div>
    <div class="corner-snow top-right">‚ùÑÔ∏è</div>
    <div class="corner-snow bottom-left">‚ùÑÔ∏è</div>
    <div class="corner-snow bottom-right">‚ùÑÔ∏è</div>
    
    <!-- Welcome Screen -->
    <div id="welcome-screen">
        <h1 class="title">‚ù§Ô∏è‚Äçüî•üéÑ Gi√°ng Sinh An L√†nh üéÑ‚ù§Ô∏è‚Äçüî•</h1>
        
        <div class="buttons-container">
            <button class="btn-main" id="btn-start">üíó START üíó</button>
            <button class="btn-main" id="btn-message">üéÅüéÄüéÅ</button>
        </div>
        
        <div class="gesture-guide">
            <div class="gesture-item">
                <div class="gesture-icon">üëä</div>
                <div class="gesture-text">Tree</div>
            </div>
            <div class="gesture-item">
                <div class="gesture-icon">üñêÔ∏è</div>
                <div class="gesture-text">Open</div>
            </div>
            <div class="gesture-item">
                <div class="gesture-icon">‚úåÔ∏è</div>
                <div class="gesture-text">Zoom</div>
            </div>
            <div class="gesture-item">
                <div class="gesture-icon">ü´∂</div>
                <div class="gesture-text">Love</div>
            </div>
        </div>
        
        <div class="footer-text">üì∑ cho ph√©p s·ª≠ d·ª•ng camera nha üì∑</div>
    </div>
    
    <!-- Message Popup -->
    <div id="message-popup">
        <div class="popup-header">
            <div class="popup-sender">üíå Trong Thai</div>
            <button class="popup-close" id="popup-close">‚úï</button>
        </div>
        <div class="popup-message" id="popup-message-text"></div>
    </div>
    
    <!-- Canvas Container -->
    <div id="canvas-container"></div>
    
    <!-- Love Mode Text -->
    <div id="love-text">‚ù§Ô∏è I LOVE YOU SO MUCH ‚ù§Ô∏è</div>
    
    <!-- Hidden Video -->
    <video id="webcam" autoplay playsinline style="display:none;"></video>
    
    <script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/","@mediapipe/tasks-vision":"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"}}</script>
    
    <script type="module">
        import * as THREE from 'three';
        import {EffectComposer} from 'three/addons/postprocessing/EffectComposer.js';
        import {RenderPass} from 'three/addons/postprocessing/RenderPass.js';
        import {UnrealBloomPass} from 'three/addons/postprocessing/UnrealBloomPass.js';
        import {FilesetResolver,HandLandmarker} from '@mediapipe/tasks-vision';
        
        // ===== CHRISTMAS MESSAGES =====
        const messages = [
            "Ch√∫c em m·ªôt m√πa Gi√°ng Sinh th·∫≠t ·∫•m √°p v√† tr√†n ng·∫≠p ni·ªÅm vui! Mong r·∫±ng nh·ªØng ƒëi·ªÅu t·ªët ƒë·∫πp nh·∫•t s·∫Ω lu√¥n ƒë·∫øn v·ªõi em. Y√™u em nhi·ªÅu! ‚ù§Ô∏èüéÑ",
            "Gi√°ng Sinh n√†y, anh ch·ªâ mu·ªën n√≥i v·ªõi em r·∫±ng: Em l√† m√≥n qu√† tuy·ªát v·ªùi nh·∫•t m√† cu·ªôc ƒë·ªùi trao cho anh. I Love You! üíùüéÖ",
            "Merry Christmas my love! D√π tuy·∫øt c√≥ r∆°i hay kh√¥ng, tr√°i tim anh lu√¥n ·∫•m √°p v√¨ c√≥ em. Y√™u em v√¥ c√πng! ‚õÑ‚ù§Ô∏è",
            "Ch√∫c em m·ªôt Gi√°ng Sinh ng·ªçt ng√†o nh∆∞ nh·ªØng chi·∫øc b√°nh g·ª´ng, lung linh nh∆∞ ƒë√®n trang tr√≠, v√† h·∫°nh ph√∫c nh∆∞ ƒë∆∞·ª£c ·ªü b√™n ng∆∞·ªùi m√¨nh y√™u. Love you! üç™‚ú®",
            "Gi√°ng Sinh v·ªÅ l√† l√∫c anh nh·∫≠n ra r·∫±ng: ƒêi·ªÅu k·ª≥ di·ªáu nh·∫•t kh√¥ng ph·∫£i l√† √¥ng gi√† Noel, m√† l√† kho·∫£nh kh·∫Øc ƒë∆∞·ª£c ·ªü b√™n em. I Love You So Much! üéÅüíï"
        ];
        
        // ===== UI HANDLERS =====
        let isStarted = false;
        
        document.getElementById('btn-start').onclick = () => {
            document.getElementById('welcome-screen').classList.add('hidden');
            isStarted = true;
            initVision();
            animate();
        };
        
        document.getElementById('btn-message').onclick = () => {
            const popup = document.getElementById('message-popup');
            const msgText = document.getElementById('popup-message-text');
            msgText.textContent = messages[Math.floor(Math.random() * messages.length)];
            popup.classList.add('show');
        };
        
        document.getElementById('popup-close').onclick = () => {
            document.getElementById('message-popup').classList.remove('show');
        };
        
        // ===== CONFIG =====
        const CFG = {
            particleCount: 3000,
            photoCount: 6,
            treeHeight: 25,
            treeMaxRadius: 10
        };
        
        // ===== STATE =====
        const state = {
            mode: 'TREE',
            handRotation: { x: 0, y: 0 },
            handDepth: 0,
            cursorPos: new THREE.Vector2(),
            time: 0,
            lastGestureTime: 0
        };
        
        const particles = [];
        const photos = [];
        const mainGroup = new THREE.Group();
        
        // ===== SCENE SETUP =====
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 300);
        camera.position.set(0, 0, 60);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.5, 0.4, 0.85);
        bloom.strength = 0.8;
        bloom.radius = 0.6;
        bloom.threshold = 0.85;
        composer.addPass(bloom);
        
        scene.add(mainGroup);
        
        // ===== LIGHTING =====
        scene.add(new THREE.AmbientLight(0xffffff, 0.2));
        const pointLight = new THREE.PointLight(0xffd700, 3, 50);
        pointLight.position.set(0, 0, 20);
        scene.add(pointLight);
        
        // ===== MATERIALS =====
        const matParticle = new THREE.MeshStandardMaterial({
            color: 0xffd700,
            emissive: 0xffaa00,
            emissiveIntensity: 1.5,
            roughness: 0.3,
            metalness: 0.8
        });
        
        const matPhoto = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xffffff,
            emissiveIntensity: 0.3,
            side: THREE.DoubleSide
        });
        
        const geoParticle = new THREE.SphereGeometry(0.15, 8, 8);
        const geoPhoto = new THREE.PlaneGeometry(3, 2);
        
        // ===== CREATE PHOTO TEXTURE =====
        function createPhotoTexture(index) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 340;
            const ctx = canvas.getContext('2d');
            
            const colors = ['#ff6b9d', '#c44569', '#f8b500', '#6a89cc', '#4a69bd', '#78e08f'];
            ctx.fillStyle = colors[index % colors.length];
            ctx.fillRect(0, 0, 512, 340);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Memory ${index + 1}`, 256, 120);
            ctx.font = '32px Arial';
            ctx.fillText('‚ù§Ô∏è', 256, 180);
            ctx.fillText('I Love You', 256, 240);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }
        
        // ===== CREATE PARTICLES =====
        for (let i = 0; i < CFG.particleCount; i++) {
            const mesh = new THREE.Mesh(geoParticle, matParticle.clone());
            
            const t = i / CFG.particleCount;
            const angle = t * 50 * Math.PI;
            const y = (t * CFG.treeHeight) - (CFG.treeHeight / 2);
            const radius = CFG.treeMaxRadius * (1 - t);
            
            const treePos = new THREE.Vector3(
                Math.cos(angle) * radius + (Math.random() - 0.5) * 1.5,
                y,
                Math.sin(angle) * radius + (Math.random() - 0.5) * 1.5
            );
            
            const sphereRadius = 25 + Math.random() * 5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const spherePos = new THREE.Vector3(
                sphereRadius * Math.sin(phi) * Math.cos(theta),
                sphereRadius * Math.sin(phi) * Math.sin(theta),
                sphereRadius * Math.cos(phi)
            );
            
            const heartAngle = (i / CFG.particleCount) * Math.PI * 2;
            const heartT = Math.sin(heartAngle);
            const heartX = 16 * Math.pow(Math.sin(heartAngle), 3);
            const heartY = 13 * Math.cos(heartAngle) - 5 * Math.cos(2 * heartAngle) - 2 * Math.cos(3 * heartAngle) - Math.cos(4 * heartAngle);
            const heartZ = Math.cos(heartAngle) * 3;
            const heartPos = new THREE.Vector3(heartX, heartY + 5, heartZ);
            
            mesh.userData = {
                treePos,
                spherePos,
                heartPos,
                blinkOffset: Math.random() * Math.PI * 2,
                blinkSpeed: 0.02 + Math.random() * 0.03
            };
            
            mesh.position.copy(treePos);
            mainGroup.add(mesh);
            particles.push(mesh);
        }
        
        // ===== CREATE PHOTOS =====
        for (let i = 0; i < CFG.photoCount; i++) {
            const tex = createPhotoTexture(i);
            const mat = matPhoto.clone();
            mat.map = tex;
            mat.needsUpdate = true;
            
            const mesh = new THREE.Mesh(geoPhoto, mat);
            
            const t = (i + 1) / (CFG.photoCount + 1);
            const angle = t * 50 * Math.PI;
            const y = (t * CFG.treeHeight) - (CFG.treeHeight / 2);
            const radius = CFG.treeMaxRadius * (1 - t) + 2;
            
            const treePos = new THREE.Vector3(
                Math.cos(angle) * radius,
                y,
                Math.sin(angle) * radius
            );
            
            const treeRot = new THREE.Euler(0, -angle, 0);
            
            const sphereRadius = 28;
            const theta = (i / CFG.photoCount) * Math.PI * 2;
            const phi = Math.PI / 2;
            const spherePos = new THREE.Vector3(
                sphereRadius * Math.sin(phi) * Math.cos(theta),
                (i - CFG.photoCount / 2) * 3,
                sphereRadius * Math.sin(phi) * Math.sin(theta)
            );
            
            const heartAngle = (i / CFG.photoCount) * Math.PI * 2;
            const heartX = 18 * Math.pow(Math.sin(heartAngle), 3);
            const heartY = 15 * Math.cos(heartAngle) - 6 * Math.cos(2 * heartAngle) - 2.5 * Math.cos(3 * heartAngle) - Math.cos(4 * heartAngle);
            const heartZ = Math.cos(heartAngle) * 2;
            const heartPos = new THREE.Vector3(heartX, heartY + 7, heartZ);
            
            mesh.userData = {
                isPhoto: true,
                treePos,
                treeRot,
                spherePos,
                heartPos,
                baseScale: new THREE.Vector3(1, 1, 1),
                glowPhase: (i / CFG.photoCount) * Math.PI * 2
            };
            
            mesh.position.copy(treePos);
            mesh.rotation.copy(treeRot);
            
            mainGroup.add(mesh);
            photos.push(mesh);
        }
        
        // ===== GESTURE RECOGNITION =====
        let vision = null;
        let lastVT = -1;
        
        async function initVision() {
            try {
                const v = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                vision = await HandLandmarker.createFromOptions(v, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1,
                    minHandDetectionConfidence: 0.5,
                    minHandPresenceConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                startCam();
            } catch (e) {
                console.warn("Vision init failed:", e);
            }
        }
        
        async function startCam() {
            const v = document.getElementById('webcam');
            try {
                v.srcObject = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                v.addEventListener("loadeddata", () => predict());
            } catch (e) {
                console.warn("Camera access failed:", e);
            }
        }
        
        async function predict() {
            if (!isStarted) {
                requestAnimationFrame(predict);
                return;
            }
            
            const v = document.getElementById('webcam');
            if (vision && v.currentTime !== lastVT) {
                lastVT = v.currentTime;
                const results = await vision.detectForVideo(v, performance.now());
                processGesture(results);
            }
            requestAnimationFrame(predict);
        }
        
        function processGesture(r) {
            if (!r.landmarks || !r.landmarks.length) {
                return;
            }
            
            const L = r.landmarks[0];
            const now = Date.now();
            
            state.handRotation.x = (L[9].y - 0.5) * 2;
            state.handRotation.y = -(L[9].x - 0.5) * 3;
            state.handDepth = L[9].z || 0;
            
            state.cursorPos.x = (1 - L[8].x) * 2 - 1;
            state.cursorPos.y = -(L[8].y * 2 - 1);
            
            const tips = [L[8], L[12], L[16], L[20]];
            let avgDist = 0;
            tips.forEach(p => avgDist += Math.hypot(p.x - L[0].x, p.y - L[0].y));
            avgDist /= 4;
            
            const indexTip = L[8];
            const middleTip = L[12];
            const ringTip = L[16];
            const pinkyTip = L[20];
            
            const indexUp = indexTip.y < L[6].y;
            const middleUp = middleTip.y < L[10].y;
            const ringDown = ringTip.y > L[14].y;
            const pinkyDown = pinkyTip.y > L[18].y;
            
            const isPeaceSign = indexUp && middleUp && ringDown && pinkyDown;
            
            const thumbPinkyDist = Math.hypot(L[4].x - L[20].x, L[4].y - L[20].y);
            const thumbHeight = L[4].y;
            const pinkyHeight = L[20].y;
            const isHeartGesture = thumbPinkyDist < 0.15 && Math.abs(thumbHeight - pinkyHeight) < 0.1 && avgDist > 0.25;
            
            if (now - state.lastGestureTime < 500) return;
            
            if (isHeartGesture) {
                if (state.mode !== 'LOVE') {
                    state.mode = 'LOVE';
                    state.lastGestureTime = now;
                    showLoveText();
                    createFloatingLoveTexts();
                }
            } else if (avgDist < 0.22) {
                if (state.mode !== 'TREE') {
                    state.mode = 'TREE';
                    state.lastGestureTime = now;
                    hideLoveText();
                    clearFloatingTexts();
                }
            } else if (isPeaceSign) {
                if (state.mode !== 'ZOOM') {
                    state.mode = 'ZOOM';
                    state.lastGestureTime = now;
                    findClosestPhoto();
                }
            } else if (avgDist > 0.38) {
                if (state.mode !== 'SPHERE') {
                    state.mode = 'SPHERE';
                    state.lastGestureTime = now;
                    hideLoveText();
                    clearFloatingTexts();
                }
            } else {
                if (state.mode === 'ZOOM') {
                    state.mode = 'TREE';
                }
            }
        }
        
        const raycaster = new THREE.Raycaster();
        let focusedPhoto = null;
        
        function findClosestPhoto() {
            raycaster.setFromCamera(state.cursorPos, camera);
            const intersects = raycaster.intersectObjects(photos);
            
            if (intersects.length > 0) {
                focusedPhoto = intersects[0].object;
            } else {
                let minDist = Infinity;
                let closest = null;
                
                photos.forEach(p => {
                    const screenPos = p.position.clone();
                    mainGroup.localToWorld(screenPos);
                    screenPos.project(camera);
                    
                    const dist = Math.hypot(
                        screenPos.x - state.cursorPos.x,
                        screenPos.y - state.cursorPos.y
                    );
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closest = p;
                    }
                });
                
                focusedPhoto = closest;
            }
        }
        
        function showLoveText() {
            document.getElementById('love-text').classList.add('show');
        }
        
        function hideLoveText() {
            document.getElementById('love-text').classList.remove('show');
        }
        
        function createFloatingLoveTexts() {
            clearFloatingTexts();
            
            const texts = ['I Love You', '‚ù§Ô∏è', 'Forever', 'üíï', 'My Love', 'üíñ'];
            const positions = [
                { left: '10%', top: '20%', size: 24 },
                { left: '85%', top: '25%', size: 32 },
                { left: '15%', top: '70%', size: 28 },
                { left: '80%', top: '65%', size: 26 },
                { left: '50%', top: '10%', size: 30 },
                { left: '50%', top: '85%', size: 28 }
            ];
            
            texts.forEach((text, i) => {
                const div = document.createElement('div');
                div.className = 'floating-love';
                div.textContent = text;
                div.style.left = positions[i].left;
                div.style.top = positions[i].top;
                div.style.fontSize = positions[i].size + 'px';
                div.style.animationDelay = (i * 0.2) + 's';
                document.body.appendChild(div);
            });
        }
        
        function clearFloatingTexts() {
            document.querySelectorAll('.floating-love').forEach(el => el.remove());
        }
        
        // ===== ANIMATION LOOP =====
        function animate() {
            if (!isStarted) return;
            
            state.time += 0.016;
            
            // Auto-rotate in TREE mode
            if (state.mode === 'TREE') {
                mainGroup.rotation.y += 0.005;
            } else if (state.mode === 'SPHERE') {
                mainGroup.rotation.y = state.handRotation.y * 0.3;
                mainGroup.rotation.x = state.handRotation.x * 0.2;
            } else if (state.mode === 'LOVE') {
                // Heart mode: KH√îNG xoay, ƒë·ª©ng y√™n
                mainGroup.rotation.y += (0 - mainGroup.rotation.y) * 0.05;
                mainGroup.rotation.x += (0 - mainGroup.rotation.x) * 0.05;
            }
            
            // Update particles
            particles.forEach((p, i) => {
                let targetPos;
                
                if (state.mode === 'TREE') {
                    targetPos = p.userData.treePos;
                } else if (state.mode === 'SPHERE') {
                    const scale = 1 - (state.handDepth * 2);
                    targetPos = p.userData.spherePos.clone().multiplyScalar(Math.max(0.3, scale));
                } else if (state.mode === 'LOVE') {
                    targetPos = p.userData.heartPos;
                } else {
                    targetPos = p.userData.treePos;
                }
                
                p.position.lerp(targetPos, 0.05);
                
                // Blinking effect
                const blink = Math.sin(state.time * 2 + p.userData.blinkOffset) * 0.5 + 0.5;
                p.material.emissiveIntensity = 1 + blink * 1.5;
            });
            
            // Update photos
            photos.forEach((p, i) => {
                let targetPos, targetRot, targetScale;
                
                if (state.mode === 'TREE') {
                    targetPos = p.userData.treePos;
                    targetRot = p.userData.treeRot;
                    targetScale = new THREE.Vector3(1, 1, 1);
                } else if (state.mode === 'SPHERE') {
                    const scale = 1 - (state.handDepth * 2);
                    targetPos = p.userData.spherePos.clone().multiplyScalar(Math.max(0.3, scale));
                    
                    const lookAtPos = new THREE.Vector3();
                    mainGroup.localToWorld(lookAtPos);
                    const dir = targetPos.clone().sub(lookAtPos).normalize();
                    targetRot = new THREE.Euler(
                        Math.atan2(dir.y, Math.sqrt(dir.x * dir.x + dir.z * dir.z)),
                        Math.atan2(dir.x, dir.z),
                        0
                    );
                    targetScale = new THREE.Vector3(1, 1, 1);
                } else if (state.mode === 'LOVE') {
                    targetPos = p.userData.heartPos;
                    targetRot = new THREE.Euler(0, 0, 0);
                    targetScale = new THREE.Vector3(1.2, 1.2, 1.2);
                } else if (state.mode === 'ZOOM' && p === focusedPhoto) {
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    const worldPos = camera.position.clone().add(camDir.multiplyScalar(20));
                    targetPos = worldPos;
                    mainGroup.worldToLocal(targetPos);
                    targetRot = new THREE.Euler(-mainGroup.rotation.x, -mainGroup.rotation.y, -mainGroup.rotation.z);
                    targetScale = new THREE.Vector3(3, 3, 3);
                } else {
                    targetPos = p.userData.treePos;
                    targetRot = p.userData.treeRot;
                    targetScale = new THREE.Vector3(1, 1, 1);
                }
                
                p.position.lerp(targetPos, 0.08);
                p.rotation.x += (targetRot.x - p.rotation.x) * 0.1;
                p.rotation.y += (targetRot.y - p.rotation.y) * 0.1;
                p.rotation.z += (targetRot.z - p.rotation.z) * 0.1;
                p.scale.lerp(targetScale, 0.08);
                
                // Glowing effect for photos
                const glow = Math.sin(state.time * 3 + p.userData.glowPhase) * 0.5 + 0.5;
                p.material.emissiveIntensity = 0.3 + glow * 0.7;
            });
            
            composer.render();
            requestAnimationFrame(animate);
        }
        
        // ===== WINDOW RESIZE =====
        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            composer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>
</html>
